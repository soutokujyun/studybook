# 二分查找 Binary Search

## 解决问题 -- 针对单调队列
在有序数组中，查找一个值是否存在

二分查找是对于有序数组查找的优化方式

二分查找 二分的是查找区间

### 代码
```
function banarySearch(arr, n, x) {
    let l = 0, r = n - 1, mid;
    while (l <= r) {
        mid = (l + r) >> 1; // 这里会超界
        if (x == arr[mid]) return mid;
        if (x > arr[mid]) l = mid + 1;
        else r = mid - 1;
    }
    return -1;
}
```
以上还有一个bug 当 l r 都趋于int的边界线值时，他们相加就会超界，所得到的mid不会是我们想要的

所以需要做一个调整
```
function banarySearch(arr, n, x) {
    let l = 0, r = n - 1, mid;
    while (l <= r) {
        mid = l + (r - l) >> 1;
        if (x == arr[mid]) return mid;
        if (x > arr[mid]) l = mid + 1;
        else r = mid - 1;
    }
    return -1;
}
```

## 二分查找 -- 泛型情况
```
A1: [0,0,0,0,0,0,1,1,1,1,1,1]

A2: [1,1,1,1,1,1,0,0,0,0,0,0]
```
现在我们要求A2中最后一个1的位置，我们只需将A2转换成A1的形式
```
A2: [1,1,1,1,1,1,0,0,0,0,0,0]
A2: [0,0,0,0,0,0,1,1,1,1,1,1] // 转换后
```
然后只需求第一个1的位置的前一位，就是原数组最后一个1的位置

0: 条件不成立  
1: 条件成立

泛型的适用情况

例子： 请找到第一个大于等于9的位置
```
[2,3,4,5,7,9,9,9,10,10,11,11,11] 

// 转成泛型
[0,0,0,0,0,1,1,1,1,1,1,1,1]

// 这样就变成0-1的二分查找算法
```
### 代码
```
// 查找第一个大于等于x的位置
function banarySearch_01(arr, n, x) {
    let l = 0, r = n - 1, mid;
    while (l < r) {
        mid = l + (r - l) >> 1;
        if (x > arr[mid]) l = mid + 1; // 条件不成立
        else r = mid; // 条件成立
    }
    return l;
}
```
优化
```
function banarySearch_02(arr, n, x) {
    let l = 0, r = n - 1, mid;
    while (r - l > 3) {
        mid = l + (r - l) >> 1;
        if (x > arr[mid]) l = mid + 1; // 条件不成立
        else r = mid; // 条件成立
    }
    // 顺序查找 -- 可以避免对边界情况的处理
    for (let i = l; i <= r; i++) {
        if (arr[i] >= x) return i;
    }
    return l;
}
```

## 扩展
二分查找可以查找单调数组的值，同时也可以通过值对其下标的查找
数组： 下标 -> 值 -> 下标
函数： 参数 -> 值 -> 参数
所以二分查找可以扩展出对单调函数参数的查找
```
f(x) = 2x

[0, 2, 4, 6, 8, 10] // 可以通过数组的值的下标找到函数多对应的参数
```
所以我们可以称： 函数为压缩的数组，数组为展开的函数
```
      映射
数组 <-----> 函数
  |          |
  \/         \/
存储         计算
 |           |
 \/          \/
空间 <-----> 时间
```