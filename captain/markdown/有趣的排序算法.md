# 算法杂谈
## 计数排序
```
1 2 1 3 3 2 2
统计1 2 3的个数，然后根据个数从小到大排列
11 222 33
```
### 应用场景
简单的*单值*排序问题中数据的值域很有限

比如统计全国14亿人的年龄做排序
## 基数排序
2位数，每个位子只能是 1 2 3字符
```
13 21 11 32 31 22 21
```
从低位到高位依次处理数据，先根据个位做计数排序，然后再根据十位做计数排序

从后往前遍历
```
1  1  1  1  2  2  3
        21

1  1  1  1  2  2  3
        21    22

1  1  1  1  2  2  3
     31 21    22
       .
       .
       .
 1  1  1  1  2  2  3
21 11 31 21 32 22 13
```
求区域尾坐标

做10位数字统计，然后从后往前遍历
```
 1  1  2  2  2  3  3
11 13 21 21 22 31 32
```

### 代码
```
function radix_sort(arr, n) {
    // n为待排序数组的大小
    let cnt = new Array(65536).fill(0)
    let temp = new Array(n)

    // low 16 bit sort
    for (let i = 0; i < n; i++) cnt[arr[i] & 0xffff] += 1 // cnt
    for (let i = 1; i < 65536; i++) cnt[i] += cnt[i - 1] // 前缀和
    for (let i = n - 1; i >= 0; --i) temp[--cnt[arr[i] & 0xffff]] = arr[i] // 归位
    // init cnt
    for (let i = 0; i < 65536; i++) cnt[i] = 0
    // high 16 bit sort
    for (let i = 0; i < n; i++) cnt[(arr[i] & 0xffff0000) >> 16] += 1 // cnt
    for (let i = 1; i < 65536; i++) cnt[i] += cnt[i - 1] // 前缀和
    for (let i = n - 1; i >= 0; --i) arr[--cnt[(arr[i] & 0xffff0000) >> 16]] = temp[i] // 归位
}
```
## 拓扑排序的基础知识
拓扑序，不唯一

依靠队列，当当前节点没有前置节点时即入度为0可以加入进队列

### 应用
