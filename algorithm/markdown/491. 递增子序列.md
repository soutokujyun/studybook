给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

示例 1：

输入：nums = [4,6,7,7]
输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
示例 2：

输入：nums = [4,4,3,2,1]
输出：[[4,4]]

### 解题思路
这一题使用的是递归枚举法，利用一个存储空间path，将以当前数为开往后遍历的符合递增条件的值都放入到存储数组中，在递归的过程中存储数组需要删除已经遍历过的值，然后将数组存入到ans数组中（还需要判断重复值）。
以例1为例，以第一个位置4开头遍历每一个值将值放入的存储数组中```[4,6] [4,6,7] [4,6,7,7]```，在递归的过程中需要删除已经遍历过的值，也就是第2，3，4位置遍历后需要从存储数组中删除，这时候递归后的存储数组就是```[4,7],[4,7,7],[4,7],[4],[]```。这时候有两个```[4,7]```需要判断重复值才能往ans添加。
### 代码
```
var findSubsequences = function(nums) {
    let ans = []
    let set = new Set()
    var getResult = function(start, path) {
        // 递增序列至少2个元素，重复值不添加到返回数组中
        if (path.length > 1 && !set.has(path.toString())) {
            set.add(path.toString())
            ans.push(path.slice())
        }

        for (let i = start; i < nums.length; i++) {
            if (path.length == 0 || path[path.length - 1] <= nums[i]) {
                // 将当前值放到存储数组中
                path.push(nums[i])
                // 向后遍历
                getResult(i + 1, path)
                // 删除已经遍历过的元素
                path.pop()
            }
        }
    }
    getResult(0, [])

    return ans
};
```