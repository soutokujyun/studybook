    设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。

    例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]
    ```
        3
    / \
    5   1
    / \ / \
    6  2 0  8
    / \
    7   4
    ```
    示例 1:
    ```
    输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
    输出: 3
    解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
    ```
    示例 2:
    ```
    输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
    输出: 5
    解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
    ```
    说明:
    ```
    所有节点的值都是唯一的。
    p、q 为不同节点且均存在于给定的二叉树中。
    ```

    ### 解题思路
    这一题可以先看2种情况

    第一种：
    ```
        3
    / \
    5   1
    p = 5 q = 1时，左右节点都存在，那么他们的共同父节点就是3
    ```
    第二种：
    ```   4
        /  \
        3    6
    / \
    5   1
    p = 3 q = 1时，3一定为1的节点，那么他们的共同父节点为3
    ```
    根据上面2种情况，
    1. 首先我们需要递归遍历每一个节点，
    2. 如果根节点节点等于p或等于q时，返回当前节点，（不需要继续递归遍历当前节点的左右子树，因为如果另外一个节点为当前节点的子节点，他们的父节点就是当前节点)
    3. 如果根节点的左右节点都有值，那么他们的共同节点就是根节点。


    ### 代码
    ```
    var lowestCommonAncestor = function(root, p, q) {
        if (!root) return root
        // 注意：p 和 q 是节点，不是数字
        if (p == root || q == root) return root

        let lNode = lowestCommonAncestor(root.left, p, q)
        let rNode = lowestCommonAncestor(root.right, p, q)

        if (lNode && rNode) return root
        if (lNode) return lNode
        return rNode
    };
    ```