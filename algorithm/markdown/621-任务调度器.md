### 题目
给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。

然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。

你需要计算完成所有任务所需要的 最短时间 。

### 解题思路
题目的意思就是得到最少时间点安排任务。

n = 2时 A 需要冷却2次才能继续安排 A 的任务： a [冷却时间] [冷却时间] a [冷却时间] [冷却时间] a

可以在 A 冷却内进行其他的任务调度：  a [b] [冷却时间] a [b] [冷却时间] a

1. 可以把任务分段，然后把最多的的任务作为每段第一个任务。
2. 接下来可以把其他次大的任务依次填空
   1. 如果任务总数量填不满矩形格子，那么执行任务时间就是矩形面积 + 剩余的任务个数
   2. 如果任务总数量填得满矩形格子，那么执行任务时间就是任务总数量
```
    A [B] []
    A [B] []
    A [B] []
    A [B] []
    A  B

   -——————————-
   | A [B] [] | 
   | A [B] [] | 矩
   | A [B] [] | 形
   | A [B] [] |
   -——————————-
     A  B       剩余的任务个数
```
设次数为n的任务有m个，k为时间间隔长度，那么 (n - 1)(k + 1) + m = 任务执行时间

最后只需选择任务总数和矩形面积+剩余任务个数最大的那个值

### 代码
```
var leastInterval = function(tasks, n) {
    if (n == 0) return tasks.length;

    const freq = _.countBy(tasks);
    const MAX_VAL = Math.max(...Object.values(freq));
    let carry = 0;
    Object.values(freq).forEach(val => {
        if (MAX_VAL == val) carry++;
    });

    return Math.max(tasks.length, (MAX_VAL - 1) * (n + 1) + carry);
};

```